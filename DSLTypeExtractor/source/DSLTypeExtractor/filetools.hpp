/*
-----------------------------------------------------------------------------
Copyright (c) 2008-2010 Diversia

This file is part of Diversia.
-----------------------------------------------------------------------------
*/

#ifndef DIVERSIA_DSLTYPEEXTRACTOR_FILETOOLS_H
#define DIVERSIA_DSLTYPEEXTRACTOR_FILETOOLS_H

#include "DSLTypeExtractor/Platform/Prerequisites.h"

#include <boost/algorithm/string/join.hpp>

namespace Diversia
{
namespace DSLTypeExtractor
{
//------------------------------------------------------------------------------

using namespace std;
using namespace boost;
using namespace boost::assign;

struct File
{
    File( const Path& rPath, const String& rIdent = "\t", const String& rComment = "// " ): 
        mPath( rPath ), mIdent( 0 ), mIdentChar( rIdent ), mAddIdent( true ), mComment( rComment ) 
        { open(); }
    virtual ~File() { close(); }

    void open() { mFile.open( mPath.string(), ios::out | ios::trunc ); }
    void close() { mFile.flush(); mFile.close(); }
    void write( const String& rString )
    {
        if( mAddIdent ) for( unsigned short i = 0; i < mIdent; ++i ) mFile << mIdentChar;
        mFile << rString;
        mAddIdent = false;
    }
    void writeLn() { mFile << endl; mAddIdent = true; }
    void writeLn( const String& rString )
    {
        if( mAddIdent ) for( unsigned short i = 0; i < mIdent; ++i ) mFile << mIdentChar;
        mFile << rString << endl; 
        mAddIdent = true;
    }
    void comment( const String& rString )
    {
        if( mAddIdent ) for( unsigned short i = 0; i < mIdent; ++i ) mFile << mIdentChar;
        mFile << mComment << rString << endl; 
        mAddIdent = true;
    }
    void addIdent() { ++mIdent; }
    void removeIdent() { --mIdent; }
    void setIdent( unsigned short ident ) { mIdent = ident; }

    Path mPath;
    ofstream mFile;
    unsigned short mIdent;
    String mIdentChar;
    bool mAddIdent;
    String mComment;
};

struct SDFFile : public File
{
    SDFFile( const Path& rPath, const String& rModule, const vector<String>& rImports = vector<String>() ): 
        File( rPath, "  ", "%% " ) 
    {
        comment( "This file is generated by DSLTypeExtractor, do not edit this file!" );
        writeLn();
        writeLn( "module " + rModule );
        writeLn();

        if( rImports.size() )
        {
            writeLn("imports");
            addIdent();
            writeLn();

            for( vector<String>::const_iterator i = rImports.begin(); i != rImports.end(); ++i )
            {
                writeLn( *i );
            }

            removeIdent();
            writeLn();
        }

        writeLn( "exports" );
        addIdent();
        writeLn();
    }
    
    void contextfree() { writeLn( "context-free syntax" ); addIdent(); writeLn(); }

    void contextfree( const String& rLeft, const String& rRight, String cons = "", vector<String> attributes = vector<String>() )
    {
        write( rLeft + " -> " + rRight );
        if( !cons.empty() ) attributes.push_back( "cons(\"" + cons + "\")" );
        if( !attributes.empty() )
        {
            write( " {" );
            write( algorithm::join( attributes, ", " ) );
            write( "}" );
        }
        writeLn();
    }
};

struct STRFile : public File
{
    STRFile( const Path& rPath, const String& rModule, const vector<String>& rImports = vector<String>() ): 
        File( rPath, "\t", "/// " )
    {
        comment( "This file is generated by DSLTypeExtractor, do not edit this file!" );
        writeLn();
        writeLn( "module " + rModule );
        writeLn();

        if( rImports.size() )
        {
            writeLn("imports");
            addIdent();
            writeLn();

            for( vector<String>::const_iterator i = rImports.begin(); i != rImports.end(); ++i )
            {
                writeLn( *i );
            }

            removeIdent();
            writeLn();
        }
    }

    void rules() { writeLn("rules"); addIdent(); writeLn(); }
    void signatures() { writeLn("signature constructors"); addIdent(); writeLn(); }

    void rule( const String& rName, const String& rTerms )
    {
        writeLn( rName + " = " + rTerms );
    }
    void rule( const String& rName, const vector<String>& rConsParams, const String& rTerms )
    {
        bool first = true;
        unsigned int count = 0;
        String params;
        String paramMatches;
        for( vector<String>::const_iterator i = rConsParams.begin(); i != rConsParams.end(); ++i )
        {
            if( !first ) params += ", ";
            String paramName = "param" + lexical_cast<String>( count );
            params += paramName;
            if( !first ) paramMatches += "; ";
            paramMatches += "<?" + *i + "> " + paramName;
            count++;
            first = false;
        }

        writeLn( rName + "(|" + params + ") = " + rTerms + "; " + paramMatches );
    }
    void matchRule( const String& rName, const String& rMatch, const String& rSubstitution )
    {
        writeLn( rName + ": " + rMatch + " -> " + rSubstitution );
    }
    void matchRule( const String& rName, const vector<String>& rConsParams, const String& rMatch, const String& rSubstitution )
    {
        bool first = true;
        unsigned int count = 0;
        String params;
        String paramMatches;
        for( vector<String>::const_iterator i = rConsParams.begin(); i != rConsParams.end(); ++i )
        {
            if( !first ) params += ", ";
            String paramName = "param" + lexical_cast<String>( count );
            params += paramName;
            if( !first ) paramMatches += "; ";
            paramMatches += "<?" + *i + "> " + paramName;
            count++;
            first = false;
        }

        writeLn( rName + "(|" + params + ") = " + "?" + rMatch + "; " + paramMatches + "; !" + rSubstitution );
    }

    void signature( const String& rLeft, const vector<String>& rParams, const String& rRight )
    {
        write( rLeft + ":" + algorithm::join( rParams, " * ") );
        if( !rRight.empty() ) write( " -> " + rRight );
        writeLn();
    }
};

//------------------------------------------------------------------------------
} // Namespace DSLTypeExtractor
} // Namespace Diversia

#endif // DIVERSIA_DSLTYPEEXTRACTOR_FILETOOLS_H
