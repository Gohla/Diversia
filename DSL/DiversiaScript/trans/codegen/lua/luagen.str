module codegen/lua/luagen

imports
	libstratego-gpp
	include/DiversiaScript
	../Lua/include/Lua
	lib/namespaces
	namespace
	signatures
	name-project
	data/events
	util
	
rules
	
	lua-tostring: ast ->
		<box2text-string( |100 )> <ast2box(|[<import-term( ../Lua/include/Lua.pp.af )>])>
	
	lua-funcdef: (name, content) -> FuncDef(FunctionName(name), ParList(), Chunk(content))
	lua-funcdef: (name, paramNames, content) -> FuncDef(FunctionName(name), ParList(paramNames), Chunk(content))
		where(<gt> (<length> paramNames, 0))
	lua-funcdef: (name, paramNames, content) -> <lua-funcdef> (name, content)
		where(<eq> (<length> paramNames, 0))
	lua-append-statements(|statements): FuncDef(name, params, Chunk(content)) -> FuncDef(name, params, Chunk(<concat> [content, statements]))
	lua-prepend-statements(|statements): FuncDef(name, params, Chunk(content)) -> FuncDef(name, params, Chunk(<concat> [statements, content]))
	lua-replace-function(|name, function): functions -> <map(\ FuncDef(FunctionName(n), _, _) -> function where <eq>(n, name) \ <+ id)> functions
	lua-stateref = !VarRef("State")
		
	// Global definitions to lua files.
	to-lua: Start(definitions) -> Chunk(<map(to-lua)> definitions)
	to-lua: obj@ObjectDef(name, properties, components, varDefs, [ defState@DefaultStateDef(defaultStateName, _, _, _, _) ], stateDefs, eventDefs) -> 
		<concat> [[Assignment([<lua-stateref>], [String(defaultStateName)])], vars, functions'''' ]
		where vars := <map(to-lua)> <object-vars> obj 
		where functions' := <map(events-to-lua)> <filter(events-to-lua-filter)> <map(object-events(|name))> <object-events>
		where functions'' := <components-to-lua> (<flatten-list> <map(to-lua)> components, functions')
		where functions''' := <objectprops-to-lua> (properties, functions'')
		where functions'''' := <states-to-lua> (<concat> [[defState], stateDefs], functions''')
	
	// Variables
	to-lua: VarDef(_{name}, _, value) -> Assignment([VarRef(name)], [<to-lua> value]) 
	
	// Events
	events-to-lua-filter: events -> events where not( <eq> (<length> events, 0) ) 
	events-to-lua: events -> <lua-funcdef> (name, <map(to-lua)> params, [
			If(Eq(<lua-stateref>, String(stateName)), 
			Chunk(<map(to-lua)> stateEventStatements), // If part
			Chunk(<map(to-lua)> objectEventStatements)) // Else part
		])
		where <eq> (<length> events, 2)
		where EventDef(name, params, objectEventStatements) := <lookup> ("", events)
		where (_, (stateName, EventDef(_, _, stateEventStatements)), _) := <take-2> events
	events-to-lua: events -> <lua-funcdef> (name, <map(to-lua)> params, [
			If(Eq(<lua-stateref>, String(stateName)), 
			Chunk(<map(to-lua)> stateEventStatements), // If part
			<map(\ (elseIfState, EventDef(_, _, elseIfStatements)) -> // ElseIf parts 
				ElseIfPart(Eq(<lua-stateref>, String(elseIfState)), Chunk(<map(to-lua)> elseIfStatements)) \)> otherEvents, 
			Chunk(<map(to-lua)> objectEventStatements)) // Else parts
		]) 
		where <gt> (<length> events, 2)
		where EventDef(name, params, objectEventStatements) := <lookup> ("", events)
		where (_, (stateName, EventDef(_, _, stateEventStatements)), otherEvents) := <take-2> events
	events-to-lua: events -> <lua-funcdef> (name, <map(to-lua)> params, <map(to-lua)> statements)
		where <eq> (<length> events, 1)
		where EventDef(name, params, statements) := <lookup> ("", events)
	events-to-lua: events -> <lua-funcdef> (name, <map(to-lua)> params, [
			If(Eq(<lua-stateref>, String(stateName)), Chunk(<map(to-lua)> statements)) // If part
		])
		where not( <lookup> ("", events) )
		where <eq> (<length> events, 1)
		where (stateName, EventDef(name, params, statements)) := <get-1> events
	events-to-lua: events -> <lua-funcdef> (name, <map(to-lua)> params, [
			IfElseIf(Eq(<lua-stateref>, String(stateName)), Chunk(<map(to-lua)> statements), // If part
			<map(\ (elseIfState, EventDef(_, _, elseIfStatements)) -> // ElseIf parts 
				ElseIfPart(Eq(<lua-stateref>, String(elseIfState)), Chunk(<map(to-lua)> elseIfStatements)) \)> otherEvents)  
		])
		where not( <lookup> ("", events) )
		where <gt> (<length> events, 1)
		where ((stateName, EventDef(name, params, statements)), otherEvents) := <take-1> events
		
	// Components
	components-to-lua: (statements, functions) -> <lua-replace-function(|"Create", createFunc)> functions
		where createFunc := <lua-prepend-statements(|statements)> <fetch-elem(?FuncDef(FunctionName("Create"), _, _))> functions
	components-to-lua: (statements, functions) -> functions'
		where not( <fetch-elem(?FuncDef(FunctionName("Create"), _, _))> functions )
		where functions' := <concat> [[<lua-funcdef> ("Create", statements)], functions] 
	to-lua: ComponentDef(name, properties) -> [
		Assignment([VarRef(name)], [Call(VarRef("Object"), "CreateComponent", Args([Access(VarRef("ComponentType"), name), String(name), False()]))]),
		<map(componentprop-to-lua(|name))> properties
	]
	componentprop-to-lua(|componentName): ComponentProp(name, exp) -> Assignment([Access(componentName, VarRef(name))], <to-lua> exp)
	destroy-component-to-lua: name -> Call(VarRef(name), "Destroy", Args([]))
	
	// Object properties
	objectprops-to-lua: (properties, functions) -> <lua-replace-function(|"Create", createFunc)> functions
		where createFunc := <lua-prepend-statements(|<map(objectprop-to-lua)> properties)> <fetch-elem(?FuncDef(FunctionName("Create"), _, _))> functions
	objectprops-to-lua: (properties, functions) -> functions'
		where not( <fetch-elem(?FuncDef(FunctionName("Create"), _, _))> functions )
		where functions' := <concat> [[<lua-funcdef> ("Create", <map(objectprop-to-lua)> properties)], functions]	
	objectprop-to-lua: ObjectProp(name, exp) -> Assignment([Access("Object", VarRef(name))], <to-lua> exp)

	// States
	states-to-lua: (states, functions) -> <concat> [functions, <map(state-to-lua)> states]
	state-to-lua: StateDef(name, propAssigns, componentDefs, varDefs, eventDefs) -> <state-to-lua> (name, propAssigns, componentDefs, varDefs, eventDefs)
	state-to-lua: DefaultStateDef(name, propAssigns, componentDefs, varDefs, eventDefs) -> <state-to-lua> (name, propAssigns, componentDefs, varDefs, eventDefs)
	state-to-lua: (name, propAssigns, componentDefs, varDefs, eventDefs) -> [enterFunc, exitFunc]
		where <gt> (<length> componentDefs, 0) <+ <gt> (<length> propAssigns, 0) <+ <fetch-elem(?EventDef("StateEnter", _, _))> eventDefs 
		where <gt> (<length> componentDefs, 0) <+ <fetch-elem(?EventDef("StateExit", _, _))> eventDefs
		where enterFunc := <state-to-lua-enterFunc> (name, propAssigns, componentDefs, eventDefs)
		where exitFunc := <state-to-lua-exitFunc> (name, componentDefs, eventDefs)
	state-to-lua: (name, propAssigns, componentDefs, varDefs, eventDefs) -> [enterFunc]
		where <gt> (<length> propAssigns, 0) <+ <fetch-elem(?EventDef("StateEnter", _, _))> eventDefs
		where not (<gt> (<length> componentDefs, 0) <+ <fetch-elem(?EventDef("StateExit", _, _))> eventDefs )
		where enterFunc := <state-to-lua-enterFunc> (name, propAssigns, componentDefs, eventDefs)
	state-to-lua: (name, propAssigns, componentDefs, varDefs, eventDefs) -> []
		where not (<gt> (<length> propAssigns, 0) <+ <fetch-elem(?EventDef("StateEnter", _, _))> eventDefs)
		where not (<gt> (<length> componentDefs, 0) <+ <fetch-elem(?EventDef("StateExit", _, _))> eventDefs )
		
	state-to-lua-enterFunc: (name, propAssigns, componentDefs, eventDefs) -> 
		<lua-funcdef> ($[StateEnter_[name]], <concat> [<map(objectprop-to-lua)> propAssigns, <map(to-lua)> componentDefs, <state-to-lua-enterFunc> eventDefs])
	state-to-lua-enterFunc: eventDefs -> <map(to-lua)> statements
		where <fetch-elem(?EventDef("StateEnter", _, statements))> eventDefs
	state-to-lua-enterFunc: eventDefs -> []
		where not (<fetch-elem(?EventDef("StateEnter", _, _))> eventDefs)
	state-to-lua-enterFunc: eventDefs -> ""
	state-to-lua-exitFunc: (name, componentDefs, eventDefs) -> <lua-funcdef> ($[StateExit_[name]], <concat> [[<map(get-name; destroy-component-to-lua)> componentDefs], 
		<state-to-lua-exitFunc> eventDefs]) 
	state-to-lua-exitFunc: eventDefs -> <map(to-lua)> statements
		where <fetch-elem(?EventDef("StateExit", _, statements))> eventDefs
	state-to-lua-exitFunc: eventDefs -> []
		where not (<fetch-elem(?EventDef("StateExit", _, _))> eventDefs)
				
rules // Expressions
	
	to-lua: True() -> True()
	to-lua: False() -> False()
	to-lua: IntConst(int) -> Number(int)
	to-lua: FloatConst(float) -> Number(float)
	to-lua: StrConst(string) -> String(string')
		where string' := <un-double-quote> string
	to-lua: StrConst(string) -> String(string)
		where not(<un-double-quote> string)
	to-lua: Vector2Const(exp1, exp2) -> Call(VarRef("Vector2"), "new", Args([<to-lua> exp1, <to-lua> exp2]))
	to-lua: Vector3Const(exp1, exp2, exp3) -> Call(VarRef("Vector3"), "new", Args([<to-lua> exp1, <to-lua> exp2, <to-lua> exp3]))
	to-lua: Vector4Const(exp1, exp2, exp3, exp4) -> Call(VarRef("Vector4"), "new", Args([<to-lua> exp1, <to-lua> exp2, <to-lua> exp3, <to-lua> exp4]))
	to-lua: VarRef(_{name}) -> VarRef(name)
	to-lua: PropRef(name, _) -> Access(VarRef("Object"), name)
	to-lua: Null() -> LuaNil()
	
	// TODO: new built in type
	// TODO: this
	to-lua: AOp(ADD(), l, r) -> Add(<to-lua> l, <to-lua> r)
	to-lua: AOp(SUB(), l, r) -> Sub(<to-lua> l, <to-lua> r)
	to-lua: AOp(MUL(), l, r) -> Mul(<to-lua> l, <to-lua> r)
	to-lua: AOp(DIV(), l, r) -> Div(<to-lua> l, <to-lua> r)
	to-lua: BOp(EQ(), l, r) -> Eq(<to-lua> l, <to-lua> r)
	to-lua: BOp(NEQ(), l, r) -> Neq(<to-lua> l, <to-lua> r)
	to-lua: BOp(LT(), l, r) -> Lt(<to-lua> l, <to-lua> r)
	to-lua: BOp(LTE(), l, r) -> Lte(<to-lua> l, <to-lua> r)
	to-lua: BOp(GT(), l, r) -> Gt(<to-lua> l, <to-lua> r)
	to-lua: BOp(GTE(), l, r) -> Gte(<to-lua> l, <to-lua> r)
	to-lua: BOp(AND(), l, r) -> And(<to-lua> l, <to-lua> r)
	to-lua: BOp(OR(), l, r) -> Or(<to-lua> l, <to-lua> r)
	to-lua: Not(exp) -> Not(<to-lua> exp)
	to-lua: Umin(exp) -> Umin(<to-lua> exp)
	to-lua: PreDec(exp) -> Sub(<to-lua> exp, Number(1))
	to-lua: PostDec(exp) -> Sub(<to-lua> exp, Number(1)) // TODO: Proper post decrement
	to-lua: Expression(PreDec(exp)) -> Assignment(exp', Sub(exp', Number(1)))
		where exp' := <to-lua> exp
	to-lua: Expression(PostDec(exp)) -> Assignment(exp', Sub(exp', Number(1)))
		where exp' := <to-lua> exp
	to-lua: PreInc(exp) -> Add(<to-lua> exp, Number(1))
	to-lua: PostInc(exp) -> Add(<to-lua> exp, Number(1)) // TODO: Proper post inc
	to-lua: Expression(PreInc(exp)) -> Assignment(exp', Add(exp', Number(1)))
		where exp' := <to-lua> exp
	to-lua: Expression(PostInc(exp)) -> Assignment(exp', Add(exp', Number(1)))
		where exp' := <to-lua> exp
	
rules // Statements
	
	to-lua: If(condition, statements) -> If(<to-lua> condition, Chunk(<map(to-lua)> statements))
	to-lua: If(condition, trueStatements, falseStatements) -> If(<to-lua> condition, Chunk(<map(to-lua)> trueStatements), Chunk(<map(to-lua)> falseStatements))
	to-lua: While(condition, statements) -> While(<to-lua> condition, Chunk(<map(to-lua)> statements))
	to-lua: Assign(exp, val) -> Assignment([<to-lua> exp], [<to-lua> val])
	to-lua: New(type, args) -> Call(VarRef(type), "new", Args(<map(to-lua)> args))
	// TODO: state change
	// TODO: switch
	// TODO: delayed statements
	// TODO: interpolation
	
rules // Other
	
	to-lua: Param(name) -> name
	to-lua: Param(name, _) -> name
	
	