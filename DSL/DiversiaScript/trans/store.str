module store

imports 
	include/DiversiaScript
	lib/namespaces
	namespace
	signatures
	
strategies
	store-all = try(store-declarations); topdown(try(store-references))
	
rules // declarations
	// Starting point
	store-declarations: d@Start(definitions) -> d
		where <map(store-declarations)> definitions
		
	// Object definitions	
	store-declarations: d@ObjectDef(name, propAssigns, componentDefs, objectDefs, varDefs, defaultStateDef, stateDefs, eventDefs) -> d
		where <store-declaration(|Objects())> (name, d)
		where <map(store-declarations(|name))> propAssigns
		where <map(store-declarations(|name))> componentDefs
		where <map(store-declarations(|name))> varDefs
		where <map(store-declarations(|name))> defaultStateDef
		where <map(store-declarations(|name))> stateDefs
		where <map(store-declarations(|name))> eventDefs
		
	// Global event definitions
	store-declarations: d@EventDef(name, _) -> d
		where <store-declaration(|Events())> (name, d)
		
	// Ignore prop assigns in object.
	store-declarations(|object): d@PropAssign(_, _) -> d
		
	// Component definitions in object.
	store-declarations(|object): d@ComponentDef(name, _) -> d
		where <store-declaration(|Components(object))> (name, d)
		
	// Variable definitions in object.
	store-declarations(|object): d@VarDef(name, _, _) -> d
		where <store-declaration(|Vars(object))> (name, d)
		
	// Event definitions in object.
	store-declarations(|object): d@EventDef(name, _, statements) -> d
		where <store-declaration(|Events(object))> (name, d)
		// TODO: store vars in event? not sure if these need to be stored since they
		// are just statements that can be directly converted to lua/c++?
		
	// State definitions in object.
	store-declarations(|object): d@DefaultStateDef(name, propAssigns, componentDefs, varDefs, eventDefs) -> d
		where <store-declaration(|States(object))> (name, d)
		where <store-declaration(|DefaultStates(object))> (name, d)
		//where <map(store-declarations(|object, name))> propAssigns
		where <map(store-declarations(|object, name))> componentDefs
		where <map(store-declarations(|object, name))> varDefs
		where <map(store-declarations(|object, name))> eventDefs
	
	store-declarations(|object): d@StateDef(name, propAssigns, componentDefs, varDefs, eventDefs) -> d
		where <store-declaration(|States(object))> (name, d)
		//where <map(store-declarations(|object, name))> propAssigns
		where <map(store-declarations(|object, name))> componentDefs
		where <map(store-declarations(|object, name))> varDefs
		where <map(store-declarations(|object, name))> eventDefs
		
	store-declarations(|object): d@StateDef(name, definitions) -> d
		where <store-declaration(|States(object))> (name, d)
		where <map(store-declarations(|object, name))> definitions
		
	// Component definitions in object and state.
	store-declarations(|object, state): d@ComponentDef(name, _) -> d
		where <store-declaration(|Components(object))> ((name, state), d)
		where <store-declaration(|Components(object, state))> (name, d)
	
	// Event definitions in object and state
	store-declarations(|object, state): d@EventDef(name, _, statements) -> d
		where <store-declaration(|Events(object, state))> (name, d)
		where <store-declaration(|ObjectEvents(object, name))> (state, (state, d))
		// TODO: store vars in event? not sure if these need to be stored since they
		// are just statements that can be directly converted to lua/c++?
			
rules // references
	
	// TODO: Fix reference mappings
	
	store-references : r@VarRef(name) -> r
		//where <store-reference(|Vars())> name
		
	store-references : r@ObjectRef(name) -> r
		//where <store-reference(|Objects())> name 
		
	store-references : r@StateRef(name) -> r
		//where <store-reference(|States())> name
	
	