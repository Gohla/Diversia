plugin SceneManager {
	SkyMaterial = "SpaceSkyBox"
	SkyType = SkyType.Box
	SkyEnabled = true
	SkyDrawFirst = true
	AmbientLight = Colour(0.23, 0.2, 0.3, 1)
}

// Camera object definition
def CameraYaw {
    Position = [0, 0.5, 0] // Standard position offset

    // Child objects
    def CameraPitch {
        def Camera {
            Position = [0, 0, 5]
            component Camera {
                Active = true
            }
        }
    }

    // Variable definitions
    var mRMB : Bool = false
    var mMouseState : MouseState = null
    prop MouseRotation : Real = 0.25
    
    // States
    default state Alive {
        // Events
        on MousePressed(Button : MouseButton) {
            if(Button == MouseButton.Right) mRMB = true;
        }
        on MouseReleased(Button : MouseButton) {
            if(Button == MouseButton.Right) mRMB = false;
        }
        on MouseMoved(State : MouseState) {
            mMouseState = MouseState(State);
        }
        on Update() {
            if(mRMB) { // If right mouse button is pressed
                // Yaw the camera
                this.Yaw(Radian(Degree(-mMouseState.X.Relative * MouseRotation)), TransformSpace.Local);

                // Pitch the camera
                var Pitch : Radian = CameraPitch.Orientation.Pitch;
                var DegreeChange : Degree = Degree(-mMouseState.Y.Relative * MouseRotation);
                var NewPitch : Degree = DegreeChange + Pitch;
                if(NewPitch < Degree(85) && NewPitch > Degree(-85)) {
                    CameraPitch.Pitch(Radian(DegreeChange), TransformSpace.Local);
                }
            }
            if(mMouseState != null) {
                // Camera distance
                var Distance : Real = CameraPitch.Camera.Position.Z;
                if(mMouseState.Z.Relative > 0) {
                     Distance = Distance - Distance / 12;
                     if(Distance < 5) Distance = 5;
                }
                else if(mMouseState.Z.Relative < 0) {
                     Distance = Distance + Distance / 12;
                     if(Distance > 50) Distance = 50;
                }
                CameraPitch.Camera.Position = [0, 0, Distance];
                
                // Clear mouse state
                mMouseState.Clear();
            }
        }
    }
    state Dead {
        // Do nothing
    }
}

// Ball object definition
def Ball {
    // Ball components
    component Mesh { 							// Visual representation of the ball.
        ShapeType = GraphicsShape.Sphere      	// Sphere is a predefined shape type.
        ShapeUV = [1, 2]        				// Vector with 2 elements.
        ShapeXSegments = 40
        ShapeRadius = 0.3
    }
    component Entity { 							// Entity that makes the mesh visible.
        Material = "Ball"
    }
    component CollisionShape { 					// Sphere collision shape
        ShapeType = PhysicsShape.Sphere
        ShapeParameters = [0.3, 1, 1]
    }
    component RigidBody { 						// Rigid body physics
        PhysicsType = PhysicsType.Dynamic
        Restitution = 0.3
        LinearDampening = 0.7
        AngularDampening = 0.7
    }
    
	var CameraYaw : CameraYaw = new CameraYaw {}
	prop Speed : Int = 10

    default state Alive {
        var mMove : Int = 0
        var mStrafe : Int = 0
        var mSpeedMultiplier : Int = 1
        
        on KeyPressed(Key : KeyboardButton, KeyCode : Int) {
            switch(Key) {
                case KeyboardButton.W: ++mMove;
                case KeyboardButton.S: --mMove;
                case KeyboardButton.A: ++mStrafe;
                case KeyboardButton.D: --mStrafe;
                case KeyboardButton.LSHIFT: mSpeedMultiplier = 2;
            }
        }
        on KeyReleased(Key : KeyboardButton, KeyCode : Int) {
            switch(Key) {
                case KeyboardButton.W: --mMove;
                case KeyboardButton.S: ++mMove;
                case KeyboardButton.A: --mStrafe;
                case KeyboardButton.D: ++mStrafe;
                case KeyboardButton.LSHIFT: mSpeedMultiplier = 1;
            }
        }
        on Update() {
            // Cap values
            if(mMove < -1)          mMove = -1;
            else if(mMove > 1)      mMove = 1;
            if(mStrafe < -1)        mStrafe = -1;
            else if(mStrafe > 1)    mStrafe = 1;
            
            // Move the ball forwards or backwards
            if(mMove != 0) {
                RigidBody.ApplyCentralForce(CameraYaw.DerivedOrientation * [0, 0, Speed * -mMove * mSpeedMultiplier]);
            }
            
            // Move the ball sideways
            if(mStrafe != 0) {
                RigidBody.ApplyCentralForce(CameraYaw.DerivedOrientation * [Speed * -mStrafe * mSpeedMultiplier, 0, 0]);
            }
        }
        on LateUpdate() {
            // Move camera to the ball
            CameraYaw.Position = this.Position;
        }
    }
    state Dead {
        // Do nothing
    }
}

def Floor {
	def FloorOffset {
		Position = [0, 10, 0]
		
	    component Mesh {
	        ShapeType = GraphicsShape.Plane
	        ShapeParameters = [2000, 2000, 1]
	        ShapeUV = [1000, 1000]
	        ShapeXSegments = 50
	        ShapeYSegments = 50
	    }
	    component Entity {
	        Material = "Floor"
	    }
    }
    component CollisionShape {
        ShapeType = PhysicsShape.Box
        ShapeParameters = [1000, 10, 1000]
    }
    component RigidBody {
        PhysicsType = PhysicsType.Kinematic
        Friction = 0.5
        Restitution = 0.3
        Mass = 0
    }
}

// Global event, the 'main' function
on Create() {
    // Create an object of type Floor at position 0, 0, 0.
    new Floor {
        Position = [0, 0, 0]
    };
    new Ball {
        Position = [0, 10, -50]
    };
}